## 使用 pipelining 提升 Redis 性能

### 请求 / 响应协议与 RTT（往返时间）

Redis 是一款基于请求 / 响应协议的采用客户端-服务器架构模型设计的 TCP 服务。

即一个请求处理完成通常需要经历如下步骤：

- 客户端向服务器发送查询请求，以进程阻塞的方式，监听 socket 端口读取服务端响应。
- 服务端处理 redis 命令，并将响应发送回客户端。

下面给出 4 个命令演示这个处理过程：

- Client: INCR X
- Server: 1
- Client: INCR X
- Server: 2
- Client: INCR X
- Server: 3
- Client: INCR X
- Server: 4

客户端和服务器通过网络进行连接。这个连接处理过程可能很快完成（通过 loopback 接口）也可能非常慢（建立了一个多次跳转的网络连接）。无论网络延迟情况如何，数据包都需要经历从客户端到服务端，然后再由服务端返回回复信息给客户端。

这个时间称之为 RTT （往返时间）。当客户端在一个逻辑处理中需要发送多个请求时（如向某个链表中同时加入多个元素，或向单个数据库中添加多个键），显而易见 RTT 对性能影响有多大。

如果实现了 loopback 接口，RTT 会显著缩短（比如，在我的本机 127.0.0.1 ping 得到的结果介于 0 到 44 毫秒之间），然而如果你需要在单词逻辑处理中多次写入是这个响应时间依然无法接受。

幸运的是有一种解决方案能够提升这种场景的性能。

### Redis 管道

一个请求 / 响应服务器可以实现即使客户端未接收到旧的请求的响应数据，服务器依然能够处理新的请求。通过这种方式，客户端能够一次发送多个命令，并且只需在最后一次性读取所有命令的响应，而不必等待命令都接收到服务端响应。

这种已经被广泛运用几十年的技术称为管道（pipelining）。比如，POP3 协议早已实现对改功能的支持，以提升从邮件服务器下载新邮件的速度。

Redis 在其早期本本中就已经支持了管道技术，所以无论你使用哪个版本的 Redis ，都能够使用其管道功能。下面是一个使用的例子：

```shell
$ (printf "PING\r\nPING\r\nPING\r\n"; sleep 1) | nc localhost 6379
+PONG
+PONG
+PONG
```

这一次我们没有为每个命令都花费了RTT开销，而是只用了一个命令的开销时间。

非常明确的，用管道顺序操作的第一个例子如下：
- Client: INCR X
- Client: INCR X
- Client: INCR X
- Client: INCR X
- Server: 1
- Server: 2
- Server: 3
- Server: 4

@TODO 

[原文](https://redis.io/topics/pipelining)
